<!DOCTYPE html>
<html>
<meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height" />
<meta name="apple-mobile-web-app-capable" content="yes" >
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- onload="WebAssembly.instantiateStreaming(fetch('canvas.wasm'), self)" -->
<body style="touch-action: manipulation; overscroll-behavior: none; pointer-events: none; margin: 0; width: 100vw; height: 100vh; background-color: black;">
    <canvas width="1260" height="1990" style="width: 630px; height: 995px; position: fixed;"></canvas>
</body>
<script type="x-shader/x-fragment" id="shaders">
    struct VertexOut {
        @builtin( position ) position : vec4f,
        @location(0) color : vec4f
    }

    @vertex 
    fn vertex_main(
        @location(0) positionX  : f32,
        @location(1) positionY  : f32,
        @location(2) positionZ  : f32,
        @location(3) positionW  : f32,
        @location(4) colorR     : f32,
        @location(5) colorG     : f32,
        @location(6) colorB     : f32,
        @location(7) colorA     : f32,
    ) -> VertexOut
    {
        var output : VertexOut;

        output.position.x = positionX;
        output.position.y = positionY;
        output.position.z = positionZ;
        output.position.w = positionW;

        output.color.r    = colorR;
        output.color.g    = colorG;
        output.color.b    = colorB;
        output.color.a    = colorA;

        return output;
    }

    @fragment
    fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
    {
        return fragData.color;
    }
</script>

<!-- <script src="../node_modules/draco3d/draco_decoder_nodejs.js"></script> -->
<script src="../draco_decoder_gltf.js"></script>
<script type="module">
    const CHUNK_TYPE_JSON                                      = 0x4E4F534A;
    const CHUNK_TYPE_BIN                                       = 0x004E4942;
    const POINT_CLOUD                                          = 0;
    const TRIANGULAR_MESH                                      = 1;
    const MESH_SEQUENTIAL_ENCODING                             = 0;
    const MESH_EDGEBREAKER_ENCODING                            = 1;
    const METADATA_FLAG_MASK                                   = 32768;
    const SEQUENTIAL_ATTRIBUTE_ENCODER_GENERIC                 = 0;
    const SEQUENTIAL_ATTRIBUTE_ENCODER_INTEGER                 = 1;
    const SEQUENTIAL_ATTRIBUTE_ENCODER_QUANTIZATION            = 2;
    const SEQUENTIAL_ATTRIBUTE_ENCODER_NORMALS                 = 3;
    const SEQUENTIAL_COMPRESSED_INDICES                        = 0;
    const SEQUENTIAL_UNCOMPRESSED_INDICES                      = 1;
    const PREDICTION_NONE                                      = -2;
    const PREDICTION_DIFFERENCE                                = 0;
    const MESH_PREDICTION_PARALLELOGRAM                        = 1;
    const MESH_PREDICTION_CONSTRAINED_MULTI_PARALLELOGRAM      = 4;
    const MESH_PREDICTION_TEX_COORDS_PORTABLE                  = 5;
    const MESH_PREDICTION_GEOMETRIC_NORMAL                     = 6;
    const PREDICTION_TRANSFORM_WRAP                            = 1;
    const PREDICTION_TRANSFORM_NORMAL_OCTAHEDRON_CANONICALIZED = 3;
    const MESH_TRAVERSAL_DEPTH_FIRST                           = 0;
    const MESH_TRAVERSAL_PREDICTION_DEGREE                     = 1;
    const MESH_VERTEX_ATTRIBUTE                                = 0;
    const MESH_CORNER_ATTRIBUTE                                = 1;
    const STANDARD_EDGEBREAKER                                 = 0;
    const VALENCE_EDGEBREAKER                                  = 2;
    const kInvalidCornerIndex                                  = -1;
    const LEFT_FACE_EDGE                                       = 0;
    const RIGHT_FACE_EDGE                                      = 1;
    const kTexCoordsNumComponents                              = 2;
    const kMaxNumParallelograms                                = 4;
    const kMaxPriority                                         = 3;
    const TOPOLOGY_C                                           = 0;
    const TOPOLOGY_S                                           = 1;
    const TOPOLOGY_L                                           = 3;
    const TOPOLOGY_R                                           = 5;
    const TOPOLOGY_E                                           = 7;
    const MIN_VALENCE                                          = 2;
    const MAX_VALENCE                                          = 7;
    const NUM_UNIQUE_VALENCES                                  = 6;
    const rabs_ans_p8_precision                                = 256;
    const rabs_ans_p10_precision                               = 1024;
    const rabs_l_base                                          = 4096;
    const IO_BASE                                              = 256;
    const L_RANS_BASE                                          = 4096;
    const TAGGED_RANS_BASE                                     = 16384;
    const TAGGED_RANS_PRECISION                                = 4096;
    const TAGGED_SYMBOLS                                       = 0;
    const RAW_SYMBOLS                                          = 1;

    function toRadians (angleInDegrees) {
        return angleInDegrees * 0.017453292519943295;  // Math.PI / 180
    };

    function setIdentity (M) {
        M[0] = 1;  M[4] = 0;  M[8] = 0;  M[12] = 0;
        M[1] = 0;  M[5] = 1;  M[9] = 0;  M[13] = 0;
        M[2] = 0;  M[6] = 0;  M[10] = 1; M[14] = 0;
        M[3] = 0;  M[7] = 0;  M[11] = 0; M[15] = 1;

        return M;
    };

    function perspective(fovy, aspect, near, far) {
        var M = new Array(16);

        if (fovy <= 0 || fovy >= 180 || aspect <= 0 || near >= far || near <= 0) {
            console.log('Invalid parameters to createPerspective');
            setIdentity(M);
        }

        var half_fovy   = toRadians(fovy) / 2;
        var top         = near * Math.tan(half_fovy);
        var bottom      = -top;
        var right       = top * aspect;
        var left        = -right;

        var sx = (2 * near) / (right - left);
        var sy = (2 * near) / (top - bottom);

        var c2 = 0 - (far + near) / (far - near);
        var c1 = 2 * (near * far) / (near - far);

        var tx = -near * (left + right) / (right - left);
        var ty = -near * (bottom + top) / (top - bottom);

        M[ 0] = sx;   M[ 4] = .0;   M[ 8] = .0;   M[12] = tx;
        M[ 1] = .0;   M[ 5] = sy;   M[ 9] = .0;   M[13] = ty;
        M[ 2] = .0;   M[ 6] = .0;   M[10] = c2;   M[14] = c1;
        M[ 3] = .0;   M[ 7] = .0;   M[11] = -1;   M[15] = .0;

        return M;
    }
    /** -----------------------------------------------------------------
     * Set a perspective projection matrix based on limits of a frustum.
     * @param left   Number Farthest left on the x-axis
     * @param right  Number Farthest right on the x-axis
     * @param bottom Number Farthest down on the y-axis
     * @param top    Number Farthest up on the y-axis
     * @param near   Number Distance to the near clipping plane along the -Z axis
     * @param far    Number Distance to the far clipping plane along the -Z axis
     * @return Float32Array A perspective transformation matrix
     */
    const near      = 0.001;
    const far       = 10000;
    const fovy      = 90;
    const aspect    = innerWidth/innerHeight;

    let projection  = perspective(
        fovy, aspect, near, far
    );

    await new Promise(d => setTimeout(d, 100));

    const filename  = "npc_d.glb";// || "1.3_OLED_IIC_128x64.STL" || "CaseV1.STL";
    const adapter   = await navigator.gpu.requestAdapter();
    const device    = await adapter.requestDevice();
    const canvas    = document.querySelector("canvas");
    const context   = canvas.getContext("webgpu");
    const buffer    = await new Promise(done => indexedDB.open("tmp").onsuccess = e => e.target.result.transaction("uploads").objectStore("uploads").get(filename).onsuccess = s => s.target.result.arrayBuffer().then(done));

    function readStl() {
        const view      = new DataView(buffer);
        const tcount    = view.getUint32(0, true);
        const vertices  = new Float32Array( tcount * 3 * 8 );
        const vertsView = new DataView( vertices.buffer );
        const readLen   = view.byteLength;

    
        const clearColor = { r: 0.0, g: 0.5, b: 1.0, a: 1.0 };
    
        
        const R=1, G=1, B=1;
        let read_offset = 0;
        let write_offset = -4;
    
        while (read_offset < readLen) {
            //skip normals
            read_offset += 12;
    
            //vertices1 - X Y Z
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
    
            //vertices1 - W R G B A
            vertsView.setFloat32( write_offset += 4, 1, true ); 
            vertsView.setFloat32( write_offset += 4, R, true ); 
            vertsView.setFloat32( write_offset += 4, G, true ); 
            vertsView.setFloat32( write_offset += 4, B, true ); 
            vertsView.setFloat32( write_offset += 4, 1, true ); 
    
            //vertices2 - X Y Z
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
    
            //vertices2 - W R G B A
            vertsView.setFloat32( write_offset += 4, 1, true ); 
            vertsView.setFloat32( write_offset += 4, R, true ); 
            vertsView.setFloat32( write_offset += 4, G, true ); 
            vertsView.setFloat32( write_offset += 4, B, true ); 
            vertsView.setFloat32( write_offset += 4, 1, true ); 
    
    
            //vertices3 - X Y Z
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
    
            //vertices3 - W R G B A
            vertsView.setFloat32( write_offset += 4, 1, true ); 
            vertsView.setFloat32( write_offset += 4, R, true ); 
            vertsView.setFloat32( write_offset += 4, G, true ); 
            vertsView.setFloat32( write_offset += 4, B, true ); 
            vertsView.setFloat32( write_offset += 4, 1, true ); 
    
            //attribs byte length
            read_offset += 2;
    
            if ((read_offset + 50) >= readLen) {
                break
            }
        }
    
    
        context.configure({
            device,
            format: navigator.gpu.getPreferredCanvasFormat(),
            alphaMode: "premultiplied",
        });
    
        const shaderModule = device.createShaderModule({
            code: shaders.text,
        });
    
        const vertexBuffers = [
            { attributes: [ { shaderLocation : 0, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 1, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 2, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 3, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 4, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 5, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 6, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 7, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
        ];
    
        const pipelineDescriptor = {
            vertex: {
                module      : shaderModule,
                entryPoint  : "vertex_main",
                buffers     : vertexBuffers,
            },
            fragment        : {
                module      : shaderModule,
                entryPoint  : "fragment_main",
                targets     : [
                    {
                        format: navigator.gpu.getPreferredCanvasFormat(),
                    },
                ],
            },
            primitive       : {
                topology    : "triangle-list",
            },
            layout          : "auto",
            label           : "triangle-list-toplogy"
        };
    
        const renderPipeline = device.createRenderPipeline(pipelineDescriptor);
    
        const vecNx1_to_vec1xN = (tarray, N = 8) => 
            new Array(N).fill(tarray.constructor).map(Class => new Class(tarray.length/N)).map(
                (varray, i) => varray.set(tarray.filter((value, j) => j % N === i)) || varray
            )
        ;
    
        const vecMax = arr => {
            let len = arr.length, 
                max = -Infinity;
    
            while (len--) {
                if (arr[len] > max) {
                    max = arr[len];
                }
            }
    
            return max;
        }
    
        const vecMin = arr => {
            let len = arr.length, 
                max = +Infinity;
    
            while (len--) {
                if (arr[len] < max) {
                    max = arr[len];
                }
            }
    
            return max;
        }
    
    
        const vecAvg = arr => {
            let len = arr.length, 
                avg = 0;
    
            while (len--) {
                avg += arr[len];
            }
    
            return avg / arr.length;
        }
    
        const vecMid = arr => {
            let max = vecMax(arr),
                min = vecMin(arr);
    
            return min + (max-min)/2;
        }
    
        const vecPad = arr => {
            let max = vecMax(arr);
            let min = vecMin(arr);
    
            return (max + min) / -2;
        };
    
        const vecAbsMax = arr => Math.max( 
            Math.abs( vecMax(arr) ), 
            Math.abs( vecMin(arr) ) 
        );
    
        const vecNormalize = (arr, k = vecAbsMax(arr)) => 
            arr.map(v => v/k)
        ;
    
        const varraysAbsMax = (varrays, l = 2) => 
            vecMax(varrays.filter((arr,i) => l>i).map(vecAbsMax.bind(null)))  
        ;
    
        const varraysNormalize = (varrays, k, l = 2) =>
            (k = k||varraysAbsMax(varrays, l)) && varrays.map(
                (arr, i) => ((i>l) && arr || vecNormalize(arr, k))
            )
        ;
    
        const varraysOriginToCenter = (varrays, k, l = 2, pad) =>
            (k = k||varraysAbsMax(varrays, l)) && varrays.map(
                (arr, i) => ((i>l) && arr || ((pad = vecPad(arr)) && arr.map(v => v + pad) || arr))
            )
        ;
    
        const varraysBufferDescriptor = (varray, i, order = "XYZWRGBA") =>
            Object({ 
                label : order.charAt(i), size : varray.byteLength,
                usage : GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            })
        ;
    
    
        const varrays = varraysOriginToCenter(varraysNormalize(vecNx1_to_vec1xN( vertices )));
    
        const vbuffers = varrays.map((varray, i) => 
            device.createBuffer(varraysBufferDescriptor(varray, i))
        );
    
        const mul_matrix_vecs   = ( matrix, vecArrays ) => {
            
            const len = vecArrays[0].length;
            const [ vecXArray, vecYArray, vecZArray, vecWArray ] = vecArrays;
            
            const [ 
                a, b, c, d, 
                e, f, g, h, 
                i, j, k, l, 
                m, n, o, p 
            ] = matrix;
    
            let index = 0;
            while (index < len) {
    
                const [ x, y, z, w ] = [ vecXArray[index], vecYArray[index], vecZArray[index], vecWArray[index] ];
    
                vecXArray[ index ] = (a * x) + (e * y) + (i * z) + (m * w);
                vecYArray[ index ] = (b * x) + (f * y) + (j * z) + (n * w);
                vecZArray[ index ] = (c * x) + (g * y) + (k * z) + (o * w);
                vecWArray[ index ] = (d * x) + (h * y) + (l * z) + (p * w);
    
                index++;
            }
        }
    
        const multiply          = function (A, B) {
            var R = new Array(16);
    
            R[0]  = (A[0] * B[ 0])    +    (A[4] * B[ 1])   +    (A[8 ] * B[ 2]) + (A[12] * B[ 3]);
            R[1]  = (A[1] * B[ 0])    +    (A[5] * B[ 1])   +    (A[ 9] * B[ 2]) + (A[13] * B[ 3]);
            R[2]  = (A[2] * B[ 0])    +    (A[6] * B[ 1])   +    (A[10] * B[ 2]) + (A[14] * B[ 3]);
            R[3]  = (A[3] * B[ 0])    +    (A[7] * B[ 1])   +    (A[11] * B[ 2]) + (A[15] * B[ 3]);
    
            R[4]  = (A[0] * B[ 4])    +    (A[4] * B[ 5])   +    (A[ 8] * B[ 6]) + (A[12] * B[ 7]);
            R[5]  = (A[1] * B[ 4])    +    (A[5] * B[ 5])   +    (A[ 9] * B[ 6]) + (A[13] * B[ 7]);
            R[6]  = (A[2] * B[ 4])    +    (A[6] * B[ 5])   +    (A[10] * B[ 6]) + (A[14] * B[ 7]);
            R[7]  = (A[3] * B[ 4])    +    (A[7] * B[ 5])   +    (A[11] * B[ 6]) + (A[15] * B[ 7]);
    
            R[8]  = (A[0] * B[ 8])    +    (A[4] * B[ 9])   +    (A[ 8] * B[10]) + (A[12] * B[11]);
            R[9]  = (A[1] * B[ 8])    +    (A[5] * B[ 9])   +    (A[ 9] * B[10]) + (A[13] * B[11]);
            R[10] = (A[2] * B[ 8])    +    (A[6] * B[ 9])   +    (A[10] * B[10]) + (A[14] * B[11]);
            R[11] = (A[3] * B[ 8])    +    (A[7] * B[ 9])   +    (A[11] * B[10]) + (A[15] * B[11]);
    
            R[12] = (A[0] * B[12])    +    (A[4] * B[13])   +    (A[ 8] * B[14]) + (A[12] * B[15]);
            R[13] = (A[1] * B[12])    +    (A[5] * B[13])   +    (A[ 9] * B[14]) + (A[13] * B[15]);
            R[14] = (A[2] * B[12])    +    (A[6] * B[13])   +    (A[10] * B[14]) + (A[14] * B[15]);
            R[15] = (A[3] * B[12])    +    (A[7] * B[13])   +    (A[11] * B[14]) + (A[15] * B[15]);
    
            return R;
        };
    
        const rot_matrix_x      = ( matrix, radians ) => {
            var sin = Math.sin( radians );
            var cos = Math.cos( radians );
    
            if (radians < 0) { sin *= -1; }
        
            var M = new Array(16);
    
            M[0] = 1;  M[4] = 0;    M[ 8] = 0;    M[12] = 0;
            M[1] = 0;  M[5] = cos;  M[ 9] = -sin; M[13] = 0;
            M[2] = 0;  M[6] = sin;  M[10] = cos;  M[14] = 0;
            M[3] = 0;  M[7] = 0;    M[11] = 0;    M[15] = 1;        
    
            return multiply( matrix, M );
        }
    
        const rot_matrix_y      = ( matrix, radians ) => {
            var sin = Math.sin( radians );
            var cos = Math.cos( radians );
    
            if (radians < 0) { sin *= -1; }
        
            var M = new Array(16);
    
            M[0] = cos;  M[4] = 0;  M[8]  = sin;    M[12] = 0;
            M[1] = 0;    M[5] = 1;  M[9]  = 0;      M[13] = 0;
            M[2] = -sin; M[6] = 0;  M[10] = cos;    M[14] = 0;
            M[3] = 0;    M[7] = 0;  M[11] = 0;      M[15] = 1;  
    
            return multiply( matrix, M );
        }
    
        const rot_matrix_z      = ( matrix, radians ) => {
            var sin = Math.sin( radians );
            var cos = Math.cos( radians );
    
            if (radians < 0) { sin *= -1; }
        
            var M = new Array(16);
    
            M[0] = cos;  M[4] = -sin;  M[8]  = 0;  M[12] = 0;
            M[1] = sin;  M[5] = cos;   M[9]  = 0;  M[13] = 0;
            M[2] = 0;    M[6] = 0;     M[10] = 1;  M[14] = 0;
            M[3] = 0;    M[7] = 0;     M[11] = 0;  M[15] = 1;
    
            return multiply( matrix, M );
        }
    
        const scale_matrix      = ( matrix, sx, sy, sz ) => {
            var M = new Array(16);
    
            M[0] = sx || 1; M[4] = 0;        M[ 8] = 0;        M[12] = 0;
            M[1] = 0;       M[5] = sy || sx; M[ 9] = 0;        M[13] = 0;
            M[2] = 0;       M[6] = 0;        M[10] = sz || sx; M[14] = 0;
            M[3] = 0;       M[7] = 0;        M[11] = 0;        M[15] = 1;
            
            return multiply( matrix, M );
        }
    
        const translate_matrix  = ( matrix, dx, dy, dz ) => {
            var M = new Array(16);
            
            M[0] = 1;  M[4] = 0;  M[ 8] = 0;  M[12] = dx || 0;
            M[1] = 0;  M[5] = 1;  M[ 9] = 0;  M[13] = dy || 0;
            M[2] = 0;  M[6] = 0;  M[10] = 1;  M[14] = dz || 0;
            M[3] = 0;  M[7] = 0;  M[11] = 0;  M[15] = 1;
    
            return multiply( matrix, M );
        }
        
    
        let scene = {
            angle_x : 0,
            delta_x : 0,
            delta_v : 0,
            delta_h : 0,
            delta_y : 0,
            angle_y : 0,
            delta_z : 0
        }
    
        projection = translate_matrix( 
            projection, 0, 0, -1 );
    
    
        function render () {
    
            let viewmat = structuredClone(projection);
            var vArrays = structuredClone(varrays);
    
            let scale_z = 1 + (scene.delta_z / (innerHeight/2));
            if (scale_z < 0) { scale_z /= -1;}
    
            let pan_x = scene.delta_h / -(innerWidth/2); 
            let pan_y = scene.delta_v /  (innerHeight/2); 
    
            let angle_x = (((scene.delta_y % innerHeight) / innerHeight) - 0.5) * (Math.PI/1) + Math.PI/-2;
            let angle_y = (((scene.delta_x % innerWidth) / innerWidth) - 0.5) * (Math.PI/1) + Math.PI/2;
    
            viewmat = translate_matrix( viewmat, pan_x, pan_y )
            viewmat = rot_matrix_x( viewmat, angle_x )
            viewmat = rot_matrix_y( viewmat, angle_y )
            viewmat = scale_matrix( viewmat, scale_z )
            // viewmat = rot_matrix_z( viewmat, Math.PI / 30 )
    
        
            mul_matrix_vecs( viewmat, vArrays )
    
            const renderPassDescriptor = {
                colorAttachments: [{
                    clearValue  : clearColor,
                    loadOp      : 'clear',
                    storeOp     : 'store',
                    view        : context.getCurrentTexture().createView()
                }]
            };
    
            const commandEncoder = device.createCommandEncoder();
            const passEncoder    = commandEncoder.beginRenderPass(renderPassDescriptor);
    
            vbuffers.forEach((buffer, i) => 
                passEncoder.setVertexBuffer(i, buffer)
            );
    
            vbuffers.forEach((buffer, i) => 
                device.queue.writeBuffer(buffer, 0, vArrays[i], 0, vArrays[i].length)
            )
                
            passEncoder.setPipeline(renderPipeline);
            passEncoder.draw( vertices.length/8 );
            passEncoder.end();
            
            device.queue.submit([commandEncoder.finish()]);
        }
    
        render()
    
        let start_of_mouse_drag;
    
        onpointerdown = event => {
            event.preventDefault();
            start_of_mouse_drag = event;
        }
    
        onpointerup = event => {
            event.preventDefault();        
            start_of_mouse_drag = null;
        }
    
        addEventListener( "wheel", event => { 
            event.preventDefault();        
    
            scene.delta_h += event.deltaX;
    
            if (Number.isInteger(event.deltaY)) {
                scene.delta_v += event.deltaY;
            }
            else {
                scene.delta_z -= event.deltaY;
            }
    
            render(); 
        }, { passive: false })
    
        onpointermove = event => {
            var delta_x, delta_y, x_limit, y_limit, new_x, new_y;
    
    
            //console.log("drag event x,y = " + event.clientX + " " + event.clientY + "  " + event.which);
            if (start_of_mouse_drag) {
                delta_x = -(event.clientX - start_of_mouse_drag.clientX) * 0.1745;
                delta_y =  (event.clientY - start_of_mouse_drag.clientY) * 0.1745;
    
                scene.delta_x += event.movementX;
                scene.delta_y += event.movementY;
    
                scene.angle_x += delta_x;
                scene.angle_y += delta_y;
                
                render();
    
                start_of_mouse_drag = event;
                event.preventDefault();
            }
        }
    
    
        console.log({
            adapter, device, canvas, context,
            renderPipeline, buffer
        })
    }

    async function readGlb () {
        const view      = new DataView( buffer );
        const magic     = view.getUint32(0, true);
        const version   = view.getUint32(4, true);
        const length    = view.getUint32(8, true);
        const decode    = TextDecoder.prototype.decode.bind( new TextDecoder ); 

        const readChunk = async ( offset = 12 ) => {
            const length = view.getUint32( offset, true ); offset += 4
            const type   = view.getUint32( offset, true ); offset += 4
            const bytes  = new Uint8Array( buffer, offset, length );

            switch (type) {
                case CHUNK_TYPE_JSON:
                    const json = JSON.parse( decode(bytes) ); offset += length;
                    console.warn("json:", json)
                break;

                case CHUNK_TYPE_BIN:
                    const isDRACO = decode( bytes.slice(0,5) ) === "DRACO"; 
                    let decoded_draco = null;

                    if (isDRACO) {
                        // Use the compact Draco decoder if available on window (draco_decoder_min.js should expose DracoDecoderMin)
                        try {

                            DracoDecoderModule().then(decoderModule => {
                                const decoder = new decoderModule.Decoder();
                                console.log(decoder)

                                switch (decoder.GetEncodedGeometryType(bytes)) 
                                {
                                    case decoderModule.TRIANGULAR_MESH:
                                        decoded_draco = new decoderModule.Mesh();
                                        decoder.DecodeArrayToMesh( bytes, bytes.length, decoded_draco );
                                        console.log(
                                            decoded_draco, 
                                            decoded_draco.num_attributes(),
                                            decoded_draco.num_faces(),
                                            decoded_draco.num_points()
                                        );

                                        const dmf32_array = new decoderModule.DracoInt32Array();
                                        const face_length = decoded_draco.num_faces();
                                        const face_values = new Float32Array( face_length * 3 );

                                        for (let i = 0; i < face_length; ++i) {
                                            decoder.GetFaceFromMesh(decoded_draco, i, dmf32_array);
                                            face_values.set([ 
                                                dmf32_array.GetValue(0), 
                                                dmf32_array.GetValue(1), 
                                                dmf32_array.GetValue(2) 
                                            ], i * 3);                                         
                                        }
                                        
                                        const attrs = 
                                        {
                                            JOINTS_0: 3,
                                            NORMAL: 1,
                                            POSITION: 0,
                                            TEXCOORD_0: 2,
                                            WEIGHTS_0: 4
                                        };
                                        
                                        const points_length     = decoded_draco.num_points();
                                        const attr_data_arrays  = new Map();

                                        Object.keys(attrs).forEach((attr) => {
                                            const attrId = attrs[attr];

                                            if (attrId < 0) {
                                                return console.error("attrId("+attr+")", attrId);
                                            }

                                            const attribute = decoder.GetAttribute(decoded_draco, attrId);
                                            const attributeData = new decoderModule.DracoFloat32Array();

                                            decoder.GetAttributeFloatForAllPoints(
                                                decoded_draco, attribute, attributeData
                                            );

                                            const attributeDataCount = attributeData.size();
                                            const attributeDataArray = new Float32Array(attributeDataCount);
                                            
                                            for (let i = 0; i < attributeDataCount; ++i) {
                                                attributeDataArray[i] = attributeData.GetValue(i);
                                            }

                                            attr_data_arrays.set(attr, attributeDataArray);

                                            decoderModule.destroy(attributeData);
                                        });


                                        console.log(face_values)
                                        console.log(decoded_draco)
                                        console.log(attr_data_arrays)
                                    break;
                                        
                                    case decoderModule.POINT_CLOUD:
                                        decoded_draco = new decoderModule.PointCloud();
                                        decoder.DecodeArrayToPointCloud( bytes, bytes.length, decoded_draco );
                                    break;
                                }

                                // decoderModule.destroy(decoder);
                            });
                            
                        } catch (e) { console.warn('draco decode failed', e); decoded_draco = null; }
                        // advance global offset by the chunk length
                        offset += length;
                    }
                    
                    console.log(decoded_draco);
                break;

                default:
                    console.error("undefined type:", type, bytes)
                break;
            }

            return offset;
        }

        console.log({
            magic: "0x" + magic.toString(16),
            version,
            length
        });

        const offset = await readChunk();
        await readChunk(offset)
    }

    readGlb();
    
</script>
</html>
