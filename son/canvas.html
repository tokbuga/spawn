<!DOCTYPE html>
<html>
<meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height" />
<meta name="apple-mobile-web-app-capable" content="yes" >
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<body style="touch-action: manipulation; overscroll-behavior: none; pointer-events: none; margin: 0; width: 100vw; height: 100vh; background-color: black;">
    <canvas width="1260" height="1990" style="width: 630px; height: 995px; position: fixed;"></canvas>
</body>

<script type="module">
    import "./decodeDracoMesh.js";

    const near      = 1e-5;
    const far       = 1e+5;
    const fovy      = 90;
    const aspect    = innerWidth/innerHeight;
    const filename  = "npc_d.glb"; //  || "e003983a-47db-42a3-9647-aaf39f7e4927.glb" || "1.3_OLED_IIC_128x64.STL" || "CaseV1.STL";
    const gl        = document.querySelector("canvas").getContext("webgl2");

    self.uiDeltaCache = {
        angle_x : 0,
        delta_x : 0,
        delta_v : 0,
        delta_h : 0,
        delta_y : 0,
        angle_y : 0,
        delta_z : 0
    }

    self.clearColor = { r: 0.0, g: 0.5, b: 1.0, a: 1.0 };

    // Kameranın pozisyonunu ve yönünü belirleyen "View" matrisi.
    // View matrisi, kameranın dünya matrisinin tersidir.
    // Kamerayı (0, 1, 10) pozisyonuna koymak, dünyayı (0, -1, -10) pozisyonuna çekmekle aynıdır.
    self.worldMatrix            = perspective(fovy, aspect, near, far);
    self.viewProjectionMatrix   = translate_matrix(worldMatrix, 0, -1, -3);

    function renderGltf(gltf) {
    
        // Basit vertex shader
        const vsSource = `
            attribute vec3 aPosition;
            uniform mat4 uMatrix;
            void main() {
                gl_Position = uMatrix * vec4(aPosition, 1.0);
            }
        `;

        // Basit fragment shader
        const fsSource = `
            precision mediump float;
            void main() {
                gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0); // Magenta
            }`;
        
        
        const program               = gl.createProgram();
        const posBuffer             = gl.createBuffer();
        const indexBuffer           = gl.createBuffer();
        const jointsBuffer          = gl.createBuffer();
        const weightsBuffer         = gl.createBuffer();
        const texCoordBuffer        = gl.createBuffer();

        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));

        gl.linkProgram(program);
        gl.useProgram(program);
        gl.clearColor(...Object.values(clearColor));
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        const posLocation               = gl.getAttribLocation(program, 'aPosition');
        const jointsLocation            = gl.getAttribLocation(program, 'aJoints');
        const weightsLocation           = gl.getAttribLocation(program, 'aWeights');
        const texCoordLocation          = gl.getAttribLocation(program, 'aTexCoord');
        
        const matrixLocation            = gl.getUniformLocation(program, 'uMatrix');
        const jointMatricesLocation     = gl.getUniformLocation(program, 'uJointMatrices');
        const baseColorLocation         = gl.getUniformLocation(program, 'uBaseColor');
        const baseColorTextureLocation  = gl.getUniformLocation(program, 'uBaseColorTexture');
        const texCoordScaleLocation     = gl.getUniformLocation(program, 'uTexCoordScale');
        
        function updateNodeWorldMatrices(node, parentWorldMatrix) {
            const localMatrix = node.matrix ? new Float32Array(node.matrix) : computeLocalMatrix(node);
            node.worldMatrix = multiplyMatrices(parentWorldMatrix, localMatrix);
            console.log(`Node ${node.node_index}:`, {
                local: Array.from(localMatrix),
                world: Array.from(node.worldMatrix)
            });
            if (node.children) {
                node.children.forEach(child_index => {
                    updateNodeWorldMatrices(gltf.nodes[child_index], node.worldMatrix);
                });
            }
        }

        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Update world matrices for all nodes recursively
            gltf.scenes[gltf.scene || 0].nodes.forEach(node_index => {
                updateNodeWorldMatrices(gltf.nodes[node_index], identityMatrix.slice());
            });

            // Update the view matrix from user input
            let viewmat = viewProjectionMatrix.slice();

            let scale_z = 1 + (uiDeltaCache.delta_z / (innerHeight/2));
            if (scale_z < 0) { scale_z /= -1;}

            let pan_x = uiDeltaCache.delta_h / -(innerWidth/2); 
            let pan_y = uiDeltaCache.delta_v /  (innerHeight/2); 
            let angle_x = (((uiDeltaCache.delta_y % innerHeight) / innerHeight) - 0.5) * (Math.PI/1) + Math.PI/2;
            let angle_y = (((uiDeltaCache.delta_x % innerWidth) / innerWidth) - 0.5) * (Math.PI/1) + Math.PI/-2;
            
            viewmat = translate_matrix( viewmat, pan_x, pan_y );
            viewmat = rot_matrix_x( viewmat, angle_x );
            viewmat = rot_matrix_y( viewmat, angle_y );
            viewmat = scale_matrix( viewmat, scale_z );
            
            gl.uniformMatrix4fv(matrixLocation, false, viewmat);
            gl.uniform2fv(texCoordScaleLocation, [1.0, 1.0]);

            // Start drawing the scene from the root nodes
            gltf.scenes[gltf.scene || 0].nodes.forEach(node_index => {
                drawNode(gltf.nodes[node_index], viewmat);
            });
        }

        function drawNode(node, parentTransformMatrix) {
            // const modelViewProjectionMatrix = multiplyMatrices(parentTransformMatrix, node.worldMatrix);
            gl.uniformMatrix4fv(matrixLocation, false, node.worldMatrix);
            console.log(`Drawing Node ${node.node_index} with matrix:`, Array.from(node.worldMatrix));

            // Draw the mesh if the node has one
            if (node.mesh > -1) {
                const mesh = gltf.meshes[node.mesh];
                mesh.primitives.forEach(drawPrimitive);
            }

            // Recursively draw children
            if (node.children) {
                node.children.forEach(child_index => {
                    drawNode(gltf.nodes[child_index], parentTransformMatrix);
                });
            }
        }
        
        function drawPrimitive(primitive) {
            // Vertex Attributes Setup
            if (primitive.attributes.POSITION > -1) {
                const accessor = accessorAt(gltf, primitive.attributes.POSITION);
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, accessor.componentData, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(posLocation);
                gl.vertexAttribPointer(posLocation, accessor.numComponents, accessor.componentType, accessor.normalized, 0, 0);
            }

            // Draw call
            if (primitive.indices > -1) {
                const accessor = accessorAt(gltf, primitive.indices);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, accessor.componentData, gl.STATIC_DRAW);
                gl.drawElements(primitive.mode, accessor.count, accessor.componentType, 0);
            }
        }        
        
        bindUIEvents( uiDeltaCache, render );
        render()
    }

    const glbBuffer = await loadFileFromIDBAsArrayBuffer( filename );
    const gltfModel = await readAsGltf( glbBuffer );

    console.warn(gltfModel);    
    renderGltf(gltfModel);
</script>
</html>
