<!DOCTYPE html>
<html>
<meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height" />
<meta name="apple-mobile-web-app-capable" content="yes" >
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- onload="WebAssembly.instantiateStreaming(fetch('canvas.wasm'), self)" -->
<body style="touch-action: manipulation; overscroll-behavior: none; pointer-events: none; margin: 0; width: 100vw; height: 100vh; background-color: black;">
    <canvas width="1260" height="1990" style="width: 630px; height: 995px; position: fixed;"></canvas>
</body>
<script type="x-shader/x-fragment" id="shaders">
    struct VertexOut {
        @builtin( position ) position : vec4f,
        @location(0) color : vec4f
    }

    @vertex 
    fn vertex_main(
        @location(0) positionX  : f32,
        @location(1) positionY  : f32,
        @location(2) positionZ  : f32,
        @location(3) positionW  : f32,
        @location(4) colorR     : f32,
        @location(5) colorG     : f32,
        @location(6) colorB     : f32,
        @location(7) colorA     : f32,
    ) -> VertexOut
    {
        var output : VertexOut;

        output.position.x = positionX;
        output.position.y = positionY;
        output.position.z = positionZ;
        output.position.w = positionW;

        output.color.r    = colorR;
        output.color.g    = colorG;
        output.color.b    = colorB;
        output.color.a    = colorA;

        return output;
    }

    @fragment
    fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
    {
        return fragData.color;
    }
</script>

<!-- <script src="../node_modules/draco3d/draco_decoder_nodejs.js"></script> -->
<script src="../draco_decoder_gltf.js"></script>
<script type="module">
    const CHUNK_TYPE_JSON                                      = 0x4E4F534A;
    const CHUNK_TYPE_BIN                                       = 0x004E4942;
    const POINT_CLOUD                                          = 0;
    const TRIANGULAR_MESH                                      = 1;
    const MESH_SEQUENTIAL_ENCODING                             = 0;
    const MESH_EDGEBREAKER_ENCODING                            = 1;
    const METADATA_FLAG_MASK                                   = 32768;
    const SEQUENTIAL_ATTRIBUTE_ENCODER_GENERIC                 = 0;
    const SEQUENTIAL_ATTRIBUTE_ENCODER_INTEGER                 = 1;
    const SEQUENTIAL_ATTRIBUTE_ENCODER_QUANTIZATION            = 2;
    const SEQUENTIAL_ATTRIBUTE_ENCODER_NORMALS                 = 3;
    const SEQUENTIAL_COMPRESSED_INDICES                        = 0;
    const SEQUENTIAL_UNCOMPRESSED_INDICES                      = 1;
    const PREDICTION_NONE                                      = -2;
    const PREDICTION_DIFFERENCE                                = 0;
    const MESH_PREDICTION_PARALLELOGRAM                        = 1;
    const MESH_PREDICTION_CONSTRAINED_MULTI_PARALLELOGRAM      = 4;
    const MESH_PREDICTION_TEX_COORDS_PORTABLE                  = 5;
    const MESH_PREDICTION_GEOMETRIC_NORMAL                     = 6;
    const PREDICTION_TRANSFORM_WRAP                            = 1;
    const PREDICTION_TRANSFORM_NORMAL_OCTAHEDRON_CANONICALIZED = 3;
    const MESH_TRAVERSAL_DEPTH_FIRST                           = 0;
    const MESH_TRAVERSAL_PREDICTION_DEGREE                     = 1;
    const MESH_VERTEX_ATTRIBUTE                                = 0;
    const MESH_CORNER_ATTRIBUTE                                = 1;
    const STANDARD_EDGEBREAKER                                 = 0;
    const VALENCE_EDGEBREAKER                                  = 2;
    const kInvalidCornerIndex                                  = -1;
    const LEFT_FACE_EDGE                                       = 0;
    const RIGHT_FACE_EDGE                                      = 1;
    const kTexCoordsNumComponents                              = 2;
    const kMaxNumParallelograms                                = 4;
    const kMaxPriority                                         = 3;
    const TOPOLOGY_C                                           = 0;
    const TOPOLOGY_S                                           = 1;
    const TOPOLOGY_L                                           = 3;
    const TOPOLOGY_R                                           = 5;
    const TOPOLOGY_E                                           = 7;
    const MIN_VALENCE                                          = 2;
    const MAX_VALENCE                                          = 7;
    const NUM_UNIQUE_VALENCES                                  = 6;
    const rabs_ans_p8_precision                                = 256;
    const rabs_ans_p10_precision                               = 1024;
    const rabs_l_base                                          = 4096;
    const IO_BASE                                              = 256;
    const L_RANS_BASE                                          = 4096;
    const TAGGED_RANS_BASE                                     = 16384;
    const TAGGED_RANS_PRECISION                                = 4096;
    const TAGGED_SYMBOLS                                       = 0;
    const RAW_SYMBOLS                                          = 1;

    function toRadians (angleInDegrees) {
        return angleInDegrees * 0.017453292519943295;  // Math.PI / 180
    };

    function setIdentity (M) {
        M[0] = 1;  M[4] = 0;  M[8] = 0;  M[12] = 0;
        M[1] = 0;  M[5] = 1;  M[9] = 0;  M[13] = 0;
        M[2] = 0;  M[6] = 0;  M[10] = 1; M[14] = 0;
        M[3] = 0;  M[7] = 0;  M[11] = 0; M[15] = 1;

        return M;
    };

    function perspective(fovy, aspect, near, far) {
        var M = new Array(16);

        if (fovy <= 0 || fovy >= 180 || aspect <= 0 || near >= far || near <= 0) {
            console.log('Invalid parameters to createPerspective');
            setIdentity(M);
        }

        var half_fovy   = toRadians(fovy) / 2;
        var top         = near * Math.tan(half_fovy);
        var bottom      = -top;
        var right       = top * aspect;
        var left        = -right;

        var sx = (2 * near) / (right - left);
        var sy = (2 * near) / (top - bottom);

        var c2 = 0 - (far + near) / (far - near);
        var c1 = 2 * (near * far) / (near - far);

        var tx = -near * (left + right) / (right - left);
        var ty = -near * (bottom + top) / (top - bottom);

        M[ 0] = sx;   M[ 4] = .0;   M[ 8] = .0;   M[12] = tx;
        M[ 1] = .0;   M[ 5] = sy;   M[ 9] = .0;   M[13] = ty;
        M[ 2] = .0;   M[ 6] = .0;   M[10] = c2;   M[14] = c1;
        M[ 3] = .0;   M[ 7] = .0;   M[11] = -1;   M[15] = .0;

        return M;
    }
    /** -----------------------------------------------------------------
     * Set a perspective projection matrix based on limits of a frustum.
     * @param left   Number Farthest left on the x-axis
     * @param right  Number Farthest right on the x-axis
     * @param bottom Number Farthest down on the y-axis
     * @param top    Number Farthest up on the y-axis
     * @param near   Number Distance to the near clipping plane along the -Z axis
     * @param far    Number Distance to the far clipping plane along the -Z axis
     * @return Float32Array A perspective transformation matrix
     */
    const near      = 0.001;
    const far       = 10000;
    const fovy      = 90;
    const aspect    = innerWidth/innerHeight;

    let projection  = perspective(
        fovy, aspect, near, far
    );

    await new Promise(d => setTimeout(d, 100));

    const filename  = "npc_d.glb";// || "1.3_OLED_IIC_128x64.STL" || "CaseV1.STL";
    const adapter   = await navigator.gpu.requestAdapter();
    const device    = await adapter.requestDevice();
    const canvas    = document.querySelector("canvas");
    const context   = canvas.getContext("webgl2");
    const buffer    = await new Promise(done => indexedDB.open("tmp").onsuccess = e => e.target.result.transaction("uploads").objectStore("uploads").get(filename).onsuccess = s => s.target.result.arrayBuffer().then(done));

    function readStl() {
        const view      = new DataView(buffer);
        const tcount    = view.getUint32(0, true);
        const vertices  = new Float32Array( tcount * 3 * 8 );
        const vertsView = new DataView( vertices.buffer );
        const readLen   = view.byteLength;

    
        const clearColor = { r: 0.0, g: 0.5, b: 1.0, a: 1.0 };
    
        
        const R=1, G=1, B=1;
        let read_offset = 0;
        let write_offset = -4;
    
        while (read_offset < readLen) {
            //skip normals
            read_offset += 12;
    
            //vertices1 - X Y Z
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
    
            //vertices1 - W R G B A
            vertsView.setFloat32( write_offset += 4, 1, true ); 
            vertsView.setFloat32( write_offset += 4, R, true ); 
            vertsView.setFloat32( write_offset += 4, G, true ); 
            vertsView.setFloat32( write_offset += 4, B, true ); 
            vertsView.setFloat32( write_offset += 4, 1, true ); 
    
            //vertices2 - X Y Z
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
    
            //vertices2 - W R G B A
            vertsView.setFloat32( write_offset += 4, 1, true ); 
            vertsView.setFloat32( write_offset += 4, R, true ); 
            vertsView.setFloat32( write_offset += 4, G, true ); 
            vertsView.setFloat32( write_offset += 4, B, true ); 
            vertsView.setFloat32( write_offset += 4, 1, true ); 
    
    
            //vertices3 - X Y Z
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
            vertsView.setFloat32( write_offset += 4, view.getFloat32(read_offset += 4) ); 
    
            //vertices3 - W R G B A
            vertsView.setFloat32( write_offset += 4, 1, true ); 
            vertsView.setFloat32( write_offset += 4, R, true ); 
            vertsView.setFloat32( write_offset += 4, G, true ); 
            vertsView.setFloat32( write_offset += 4, B, true ); 
            vertsView.setFloat32( write_offset += 4, 1, true ); 
    
            //attribs byte length
            read_offset += 2;
    
            if ((read_offset + 50) >= readLen) {
                break
            }
        }
    
    
        context.configure({
            device,
            format: navigator.gpu.getPreferredCanvasFormat(),
            alphaMode: "premultiplied",
        });
    
        const shaderModule = device.createShaderModule({
            code: shaders.text,
        });
    
        const vertexBuffers = [
            { attributes: [ { shaderLocation : 0, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 1, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 2, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 3, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 4, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 5, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 6, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
            { attributes: [ { shaderLocation : 7, format : "float32", offset : 0 } ], arrayStride : 4, stepMode : "vertex" },
        ];
    
        const pipelineDescriptor = {
            vertex: {
                module      : shaderModule,
                entryPoint  : "vertex_main",
                buffers     : vertexBuffers,
            },
            fragment        : {
                module      : shaderModule,
                entryPoint  : "fragment_main",
                targets     : [
                    {
                        format: navigator.gpu.getPreferredCanvasFormat(),
                    },
                ],
            },
            primitive       : {
                topology    : "triangle-list",
            },
            layout          : "auto",
            label           : "triangle-list-toplogy"
        };
    
        const renderPipeline = device.createRenderPipeline(pipelineDescriptor);
    
        const vecNx1_to_vec1xN = (tarray, N = 8) => 
            new Array(N).fill(tarray.constructor).map(Class => new Class(tarray.length/N)).map(
                (varray, i) => varray.set(tarray.filter((value, j) => j % N === i)) || varray
            )
        ;
    
        const vecMax = arr => {
            let len = arr.length, 
                max = -Infinity;
    
            while (len--) {
                if (arr[len] > max) {
                    max = arr[len];
                }
            }
    
            return max;
        }
    
        const vecMin = arr => {
            let len = arr.length, 
                max = +Infinity;
    
            while (len--) {
                if (arr[len] < max) {
                    max = arr[len];
                }
            }
    
            return max;
        }
    
    
        const vecAvg = arr => {
            let len = arr.length, 
                avg = 0;
    
            while (len--) {
                avg += arr[len];
            }
    
            return avg / arr.length;
        }
    
        const vecMid = arr => {
            let max = vecMax(arr),
                min = vecMin(arr);
    
            return min + (max-min)/2;
        }
    
        const vecPad = arr => {
            let max = vecMax(arr);
            let min = vecMin(arr);
    
            return (max + min) / -2;
        };
    
        const vecAbsMax = arr => Math.max( 
            Math.abs( vecMax(arr) ), 
            Math.abs( vecMin(arr) ) 
        );
    
        const vecNormalize = (arr, k = vecAbsMax(arr)) => 
            arr.map(v => v/k)
        ;
    
        const varraysAbsMax = (varrays, l = 2) => 
            vecMax(varrays.filter((arr,i) => l>i).map(vecAbsMax.bind(null)))  
        ;
    
        const varraysNormalize = (varrays, k, l = 2) =>
            (k = k||varraysAbsMax(varrays, l)) && varrays.map(
                (arr, i) => ((i>l) && arr || vecNormalize(arr, k))
            )
        ;
    
        const varraysOriginToCenter = (varrays, k, l = 2, pad) =>
            (k = k||varraysAbsMax(varrays, l)) && varrays.map(
                (arr, i) => ((i>l) && arr || ((pad = vecPad(arr)) && arr.map(v => v + pad) || arr))
            )
        ;
    
        const varraysBufferDescriptor = (varray, i, order = "XYZWRGBA") =>
            Object({ 
                label : order.charAt(i), size : varray.byteLength,
                usage : GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            })
        ;
    
    
        const varrays = varraysOriginToCenter(varraysNormalize(vecNx1_to_vec1xN( vertices )));
    
        const vbuffers = varrays.map((varray, i) => 
            device.createBuffer(varraysBufferDescriptor(varray, i))
        );
    
        const mul_matrix_vecs   = ( matrix, vecArrays ) => {
            
            const len = vecArrays[0].length;
            const [ vecXArray, vecYArray, vecZArray, vecWArray ] = vecArrays;
            
            const [ 
                a, b, c, d, 
                e, f, g, h, 
                i, j, k, l, 
                m, n, o, p 
            ] = matrix;
    
            let index = 0;
            while (index < len) {
    
                const [ x, y, z, w ] = [ vecXArray[index], vecYArray[index], vecZArray[index], vecWArray[index] ];
    
                vecXArray[ index ] = (a * x) + (e * y) + (i * z) + (m * w);
                vecYArray[ index ] = (b * x) + (f * y) + (j * z) + (n * w);
                vecZArray[ index ] = (c * x) + (g * y) + (k * z) + (o * w);
                vecWArray[ index ] = (d * x) + (h * y) + (l * z) + (p * w);
    
                index++;
            }
        }
    
        const multiply          = function (A, B) {
            var R = new Array(16);
    
            R[0]  = (A[0] * B[ 0])    +    (A[4] * B[ 1])   +    (A[8 ] * B[ 2]) + (A[12] * B[ 3]);
            R[1]  = (A[1] * B[ 0])    +    (A[5] * B[ 1])   +    (A[ 9] * B[ 2]) + (A[13] * B[ 3]);
            R[2]  = (A[2] * B[ 0])    +    (A[6] * B[ 1])   +    (A[10] * B[ 2]) + (A[14] * B[ 3]);
            R[3]  = (A[3] * B[ 0])    +    (A[7] * B[ 1])   +    (A[11] * B[ 2]) + (A[15] * B[ 3]);
    
            R[4]  = (A[0] * B[ 4])    +    (A[4] * B[ 5])   +    (A[ 8] * B[ 6]) + (A[12] * B[ 7]);
            R[5]  = (A[1] * B[ 4])    +    (A[5] * B[ 5])   +    (A[ 9] * B[ 6]) + (A[13] * B[ 7]);
            R[6]  = (A[2] * B[ 4])    +    (A[6] * B[ 5])   +    (A[10] * B[ 6]) + (A[14] * B[ 7]);
            R[7]  = (A[3] * B[ 4])    +    (A[7] * B[ 5])   +    (A[11] * B[ 6]) + (A[15] * B[ 7]);
    
            R[8]  = (A[0] * B[ 8])    +    (A[4] * B[ 9])   +    (A[ 8] * B[10]) + (A[12] * B[11]);
            R[9]  = (A[1] * B[ 8])    +    (A[5] * B[ 9])   +    (A[ 9] * B[10]) + (A[13] * B[11]);
            R[10] = (A[2] * B[ 8])    +    (A[6] * B[ 9])   +    (A[10] * B[10]) + (A[14] * B[11]);
            R[11] = (A[3] * B[ 8])    +    (A[7] * B[ 9])   +    (A[11] * B[10]) + (A[15] * B[11]);
    
            R[12] = (A[0] * B[12])    +    (A[4] * B[13])   +    (A[ 8] * B[14]) + (A[12] * B[15]);
            R[13] = (A[1] * B[12])    +    (A[5] * B[13])   +    (A[ 9] * B[14]) + (A[13] * B[15]);
            R[14] = (A[2] * B[12])    +    (A[6] * B[13])   +    (A[10] * B[14]) + (A[14] * B[15]);
            R[15] = (A[3] * B[12])    +    (A[7] * B[13])   +    (A[11] * B[14]) + (A[15] * B[15]);
    
            return R;
        };
    
        const rot_matrix_x      = ( matrix, radians ) => {
            var sin = Math.sin( radians );
            var cos = Math.cos( radians );
    
            if (radians < 0) { sin *= -1; }
        
            var M = new Array(16);
    
            M[0] = 1;  M[4] = 0;    M[ 8] = 0;    M[12] = 0;
            M[1] = 0;  M[5] = cos;  M[ 9] = -sin; M[13] = 0;
            M[2] = 0;  M[6] = sin;  M[10] = cos;  M[14] = 0;
            M[3] = 0;  M[7] = 0;    M[11] = 0;    M[15] = 1;        
    
            return multiply( matrix, M );
        }
    
        const rot_matrix_y      = ( matrix, radians ) => {
            var sin = Math.sin( radians );
            var cos = Math.cos( radians );
    
            if (radians < 0) { sin *= -1; }
        
            var M = new Array(16);
    
            M[0] = cos;  M[4] = 0;  M[8]  = sin;    M[12] = 0;
            M[1] = 0;    M[5] = 1;  M[9]  = 0;      M[13] = 0;
            M[2] = -sin; M[6] = 0;  M[10] = cos;    M[14] = 0;
            M[3] = 0;    M[7] = 0;  M[11] = 0;      M[15] = 1;  
    
            return multiply( matrix, M );
        }
    
        const rot_matrix_z      = ( matrix, radians ) => {
            var sin = Math.sin( radians );
            var cos = Math.cos( radians );
    
            if (radians < 0) { sin *= -1; }
        
            var M = new Array(16);
    
            M[0] = cos;  M[4] = -sin;  M[8]  = 0;  M[12] = 0;
            M[1] = sin;  M[5] = cos;   M[9]  = 0;  M[13] = 0;
            M[2] = 0;    M[6] = 0;     M[10] = 1;  M[14] = 0;
            M[3] = 0;    M[7] = 0;     M[11] = 0;  M[15] = 1;
    
            return multiply( matrix, M );
        }
    
        const scale_matrix      = ( matrix, sx, sy, sz ) => {
            var M = new Array(16);
    
            M[0] = sx || 1; M[4] = 0;        M[ 8] = 0;        M[12] = 0;
            M[1] = 0;       M[5] = sy || sx; M[ 9] = 0;        M[13] = 0;
            M[2] = 0;       M[6] = 0;        M[10] = sz || sx; M[14] = 0;
            M[3] = 0;       M[7] = 0;        M[11] = 0;        M[15] = 1;
            
            return multiply( matrix, M );
        }
    
        const translate_matrix  = ( matrix, dx, dy, dz ) => {
            var M = new Array(16);
            
            M[0] = 1;  M[4] = 0;  M[ 8] = 0;  M[12] = dx || 0;
            M[1] = 0;  M[5] = 1;  M[ 9] = 0;  M[13] = dy || 0;
            M[2] = 0;  M[6] = 0;  M[10] = 1;  M[14] = dz || 0;
            M[3] = 0;  M[7] = 0;  M[11] = 0;  M[15] = 1;
    
            return multiply( matrix, M );
        }
        
    
        let scene = {
            angle_x : 0,
            delta_x : 0,
            delta_v : 0,
            delta_h : 0,
            delta_y : 0,
            angle_y : 0,
            delta_z : 0
        }
    
        projection = translate_matrix( 
            projection, 0, 0, -1 );
    
    
        function render () {
    
            let viewmat = structuredClone(projection);
            var vArrays = structuredClone(varrays);
    
            let scale_z = 1 + (scene.delta_z / (innerHeight/2));
            if (scale_z < 0) { scale_z /= -1;}
    
            let pan_x = scene.delta_h / -(innerWidth/2); 
            let pan_y = scene.delta_v /  (innerHeight/2); 
    
            let angle_x = (((scene.delta_y % innerHeight) / innerHeight) - 0.5) * (Math.PI/1) + Math.PI/-2;
            let angle_y = (((scene.delta_x % innerWidth) / innerWidth) - 0.5) * (Math.PI/1) + Math.PI/2;
    
            viewmat = translate_matrix( viewmat, pan_x, pan_y )
            viewmat = rot_matrix_x( viewmat, angle_x )
            viewmat = rot_matrix_y( viewmat, angle_y )
            viewmat = scale_matrix( viewmat, scale_z )
            // viewmat = rot_matrix_z( viewmat, Math.PI / 30 )
    
        
            mul_matrix_vecs( viewmat, vArrays )
    
            const renderPassDescriptor = {
                colorAttachments: [{
                    clearValue  : clearColor,
                    loadOp      : 'clear',
                    storeOp     : 'store',
                    view        : context.getCurrentTexture().createView()
                }]
            };
    
            const commandEncoder = device.createCommandEncoder();
            const passEncoder    = commandEncoder.beginRenderPass(renderPassDescriptor);
    
            vbuffers.forEach((buffer, i) => 
                passEncoder.setVertexBuffer(i, buffer)
            );
    
            vbuffers.forEach((buffer, i) => 
                device.queue.writeBuffer(buffer, 0, vArrays[i], 0, vArrays[i].length)
            )
                
            passEncoder.setPipeline(renderPipeline);
            passEncoder.draw( vertices.length/8 );
            passEncoder.end();
            
            device.queue.submit([commandEncoder.finish()]);
        }
    
        render()
    
        let start_of_mouse_drag;
    
        onpointerdown = event => {
            event.preventDefault();
            start_of_mouse_drag = event;
        }
    
        onpointerup = event => {
            event.preventDefault();        
            start_of_mouse_drag = null;
        }
    
        addEventListener( "wheel", event => { 
            event.preventDefault();        
    
            scene.delta_h += event.deltaX;
    
            if (Number.isInteger(event.deltaY)) {
                scene.delta_v += event.deltaY;
            }
            else {
                scene.delta_z -= event.deltaY;
            }
    
            render(); 
        }, { passive: false })
    
        onpointermove = event => {
            var delta_x, delta_y, x_limit, y_limit, new_x, new_y;
    
    
            //console.log("drag event x,y = " + event.clientX + " " + event.clientY + "  " + event.which);
            if (start_of_mouse_drag) {
                delta_x = -(event.clientX - start_of_mouse_drag.clientX) * 0.1745;
                delta_y =  (event.clientY - start_of_mouse_drag.clientY) * 0.1745;
    
                scene.delta_x += event.movementX;
                scene.delta_y += event.movementY;
    
                scene.angle_x += delta_x;
                scene.angle_y += delta_y;
                
                render();
    
                start_of_mouse_drag = event;
                event.preventDefault();
            }
        }
    
    
        console.log({
            adapter, device, canvas, context,
            renderPipeline, buffer
        })
    }

    async function readAsGltf ( source ) {
        const view = new DataView( source );
        
        const readChunk = async ( offset, length, headers ) => {
            let result = null;
            
            const chunkLength = view.getUint32( offset, true ); offset += 4
            const chunkType   = view.getUint32( offset, true ); offset += 4

            if (offset + chunkLength > source.byteLength) {
                throw new RangeError("ERROR_BUFFER_EXCEED: " + JSON.stringify({
                    offset, 
                    length,
                    chunkLength,
                    chunkType, 
                    sourceByteLength: source.byteLength
                }, null, "\t"))
            }

            const chunkData = new Uint8Array( 
                source, offset, Math.min(chunkLength, length || chunkLength) 
            );
            
            switch ( chunkType ) {
                case CHUNK_TYPE_JSON:
                    return Object.defineProperty(
                        JSON.parse( decode(chunkData) ), "byteLength", {
                            value : chunkData.byteLength + 8
                        }
                    ); 
                break;

                case CHUNK_TYPE_BIN:
                    const isDRACO = decode( chunkData.slice(0,5) ) === "DRACO"; 

                    if (isDRACO) {
                        return await DracoDecoderModule().then(async decoderModule => {
                            
                            const decoder = new decoderModule.Decoder();
                            let decoded_draco = null;
                            
                            switch (decoder.GetEncodedGeometryType(chunkData)) 
                            {
                                case decoderModule.TRIANGULAR_MESH:
                                    decoded_draco = new decoderModule.Mesh();
                                    decoder.DecodeArrayToMesh( chunkData, chunkData.length, decoded_draco );

                                    const dmf32_array = new decoderModule.DracoInt32Array();
                                    const face_length = decoded_draco.num_faces();
                                    const face_values = new Int32Array( face_length * 3 );

                                    for (let i = 0; i < face_length; ++i) {
                                        decoder.GetFaceFromMesh(decoded_draco, i, dmf32_array);

                                        face_values.set([ 
                                            dmf32_array.GetValue(0), 
                                            dmf32_array.GetValue(1), 
                                            dmf32_array.GetValue(2) 
                                        ], i * 3);                                         
                                    }
                                    
                                    decoderModule.destroy(dmf32_array);

                                    const points_length = decoded_draco.num_points();

                                    let alen = decoded_draco.num_attributes();
                                    const attributes = new Array(alen);
                                    while (alen--) {
                                        const attribute = decoder.GetAttribute(decoded_draco, alen);
                                        
                                        if (attribute.unique_id() < 0) {
                                            return console.error("attr(?)", alen);
                                        }

                                        const data_temp = new decoderModule.DracoFloat32Array();
                                        
                                        decoder.GetAttributeFloatForAllPoints(
                                            decoded_draco, attribute, data_temp
                                        );

                                        const data_type = attribute.data_type();
                                        const data_size = data_temp.size();
                                        
                                        switch (data_type) {
                                            case decoderModule.DT_BOOL     : attributes[alen] = new Uint8Array(data_size); break;      
                                            case decoderModule.DT_FLOAT32  : attributes[alen] = new Float32Array(data_size); break;          
                                            case decoderModule.DT_FLOAT64  : attributes[alen] = new Float64Array(data_size); break;          
                                            case decoderModule.DT_INT8     : attributes[alen] = new Int8Array(data_size); break;      
                                            case decoderModule.DT_INT16    : attributes[alen] = new Int16Array(data_size); break;      
                                            case decoderModule.DT_INT32    : attributes[alen] = new Int32Array(data_size); break;      
                                            case decoderModule.DT_INT64    : attributes[alen] = new BigInt64Array(data_size); break;      
                                            case decoderModule.DT_UINT8    : attributes[alen] = new Uint8Array(data_size); break;      
                                            case decoderModule.DT_UINT16   : attributes[alen] = new Uint16Array(data_size); break;          
                                            case decoderModule.DT_UINT32   : attributes[alen] = new Uint32Array(data_size); break;          
                                            case decoderModule.DT_UINT64   : attributes[alen] = new BigUint64Array(data_size); break;          
                                        }

                                        for (let i = 0; i < data_size; ++i) {
                                            attributes[alen][i] = data_temp.GetValue(i);
                                        }

                                        Object.defineProperties( attributes[alen], {
                                                attribute_type: { value: attribute.attribute_type() },
                                                byte_offset: { value: attribute.byte_offset() },
                                                byte_stride: { value: attribute.byte_stride() },
                                                data_type: { value: data_type },
                                                normalized: { value: attribute.normalized() },
                                                num_components: { value: attribute.num_components() },
                                                size: { value: attribute.size() },
                                                unique_id: { value: attribute.unique_id() },
                                            }
                                        )

                                        decoderModule.destroy(data_temp);
                                    }

                                    decoderModule.destroy(decoded_draco);
                                    decoderModule.destroy(decoder);
                                    decoderModule = null;

                                    return {
                                        faces : {
                                            length: face_length,
                                            values: face_values
                                        },
                                        points : {
                                            length: points_length,
                                        },
                                        attributes
                                    }
                                break;
                                    
                                case decoderModule.POINT_CLOUD:
                                    decoded_draco = new decoderModule.PointCloud();
                                    decoder.DecodeArrayToPointCloud( 
                                        chunkData, 
                                        chunkData.length, 
                                        decoded_draco 
                                    );

                                    decoderModule.destroy(decoded_draco);
                                    decoderModule.destroy(decoder);
                                    decoderModule = null;

                                    return {

                                    }
                                break;
                            }
                        });
                    } else { throw "BIN_TYPE_UNKNOWN" };
                break;

                default: throw "CHUNK_TYPE_UNKNOWN:"; break;
            }

            return result;
        }


        let offset = 0;
        
        const magic     = view.getUint32(offset, true); offset += 4;
        const version   = view.getUint32(offset, true); offset += 4;
        const length    = view.getUint32(offset, true); offset += 4;

        const decode    = TextDecoder.prototype.decode.bind( new TextDecoder ); 
        const headers   = await readChunk( offset, length );

        offset += headers.byteLength;
        for await (const chunk of headers.buffers) 
        {
            chunk.data = await readChunk(
                chunk.byteOffset = offset, 
                chunk.byteLength, headers 
            );

            offset += chunk.byteLength;
        }

        return headers;
    }

    const gltf = await readAsGltf(buffer);
    
    // GLTF ile DRACO verisini ilişkilendir ve çiz
    function renderGltf(gltf) {
        const gl = context;
        
        // Basit vertex shader
        const vsSource = `
            attribute vec3 aPosition;
            uniform mat4 uMatrix;
            void main() {
                gl_Position = uMatrix * vec4(aPosition, 1.0);
            }`;
        
        // Basit fragment shader
        const fsSource = `
            precision mediump float;
            void main() {
                gl_FragColor = vec4(0.8, 0.8, 0.8, 1.0);
            }`;
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }
        
        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
        gl.linkProgram(program);
        gl.useProgram(program);
        
        // Her mesh için
        gltf.meshes?.forEach(mesh => {
            mesh.primitives?.forEach(primitive => {
                const dracoExt = primitive.extensions?.KHR_draco_mesh_compression;
                if (dracoExt) {
                    const bufferView = gltf.bufferViews[dracoExt.bufferView];
                    const dracoData = gltf.buffers[bufferView.buffer].data;
                    
                    // DRACO attribute mapping
                    const positionAttr = dracoData.attributes.find(attr => 
                        attr.attribute_type === 0 // POSITION
                    );
                    
                    if (positionAttr) {
                        // Position buffer oluştur
                        const posBuffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, positionAttr, gl.STATIC_DRAW);
                        
                        // Index buffer oluştur
                        const indexBuffer = gl.createBuffer();
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, dracoData.faces.values, gl.STATIC_DRAW);
                        
                        // Attribute bağla
                        const posLocation = gl.getAttribLocation(program, 'aPosition');
                        gl.enableVertexAttribArray(posLocation);
                        gl.vertexAttribPointer(posLocation, 3, gl.FLOAT, false, 0, 0);
                        
                        // Basit perspektif matrix
                        const matrix = new Float32Array([
                            1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            0, -.5, 0, 1
                        ]);
                        
                        const matrixLocation = gl.getUniformLocation(program, 'uMatrix');
                        gl.uniformMatrix4fv(matrixLocation, false, matrix);
                        
                        // Çiz
                        gl.clearColor(0.1, 0.1, 0.1, 1.0);
                        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                        gl.drawElements(gl.TRIANGLES, dracoData.faces.length * 3, gl.UNSIGNED_INT, 0);
                    }
                }
            });
        });
    }
    
    renderGltf(gltf);
    console.log(gltf)
    
</script>
</html>
